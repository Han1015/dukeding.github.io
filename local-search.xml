<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gitlab On Docker</title>
    <link href="/dukeding.github.io/2024/12/16/Gitlab-On-Docker/"/>
    <url>/dukeding.github.io/2024/12/16/Gitlab-On-Docker/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cross Orign I</title>
    <link href="/dukeding.github.io/2024/06/24/Cross-Orign/"/>
    <url>/dukeding.github.io/2024/06/24/Cross-Orign/</url>
    
    <content type="html"><![CDATA[<h2 id="What-is-CORS"><a href="#What-is-CORS" class="headerlink" title="What is CORS"></a>What is CORS</h2><h3 id="The-CORS-error-message"><a href="#The-CORS-error-message" class="headerlink" title="The CORS error message"></a>The <strong>CORS</strong> error message</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">request has been blocked <span class="hljs-keyword">by</span> CORS <span class="hljs-keyword">policy</span>: <span class="hljs-keyword">No</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-keyword">header</span> <span class="hljs-keyword">is</span> present <span class="hljs-keyword">on</span> the requested resource.<br></code></pre></td></tr></table></figure><p>I believe that the above errors can often occur when the front-end initiates a request, and many developers may not know how to solve them, or even who to solve them. In fact, this is a typical <strong>CORS</strong>, and the vast majority of these situations cannot be solved by the front-end, because prohibiting cross domain access is originally a <strong>web security</strong> specification. If the front-end can bypass it, what security significance does it have?</p><h3 id="What-is-Cross-Orign"><a href="#What-is-Cross-Orign" class="headerlink" title="What is Cross Orign"></a>What is <strong>Cross Orign</strong></h3><p>The commonly used term ‘<strong>cross origin</strong>‘ actually refers to resource requests that span different origins. <strong>Same Origin</strong> is a network security concept used to define whether two URLs belong to the same Origin. Same Origin Policy is a security mechanism used by browsers to restrict interactions between different sources and protect user data from malicious websites.</p><h4 id="How-to-Determine-if-Two-URLs-Are-Same-Origin"><a href="#How-to-Determine-if-Two-URLs-Are-Same-Origin" class="headerlink" title="How to Determine if Two URLs Are Same-Origin"></a>How to Determine if Two URLs Are Same-Origin</h4><p>Two URLs are considered to have the same origin if they share:<br><strong>Protocol</strong> (e.g., http or https)<br><strong>Domain</strong> (e.g., example.com)<br><strong>Port</strong> (e.g., :80, :443)</p><p>The Same-Origin Policy focuses on protecting sensitive user data (like cookies, DOM, and storage) rather than restricting external resources. Allowing unrestricted use of<br>&lt;script&gt;, &lt;video&gt;, and &lt;img&gt; ensures the web remains functional while other safeguards like CORS and CSP mitigate potential security risks. The interactions restricted by the Same-Origin Policy include the following three types:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">Cross-Origin Network Access:<br><span class="hljs-number">1</span>. This includes resources loaded via XMLHttpRequest, fetch, <span class="hljs-built_in">or</span> elements such <span class="hljs-keyword">as</span> <span class="hljs-symbol">&lt;script&gt;</span>, <span class="hljs-symbol">&lt;link&gt;</span>, <span class="hljs-symbol">&lt;img&gt;</span>, <span class="hljs-symbol">&lt;video&gt;</span>, <span class="hljs-symbol">&lt;audio&gt;</span>, <span class="hljs-symbol">&lt;object&gt;</span>, <span class="hljs-symbol">&lt;embed&gt;</span>, <span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;iframe&gt;</span>.<br><br><span class="hljs-number">2</span>. Cross-Origin DOM <span class="hljs-built_in">and</span> API Access:<br>This mainly refers <span class="hljs-keyword">to</span> restrictions <span class="hljs-keyword">on</span> accessing the content of iframe elements <span class="hljs-built_in">and</span> the content of windows opened by window.<span class="hljs-keyword">open</span>.<br><br><span class="hljs-number">3</span>. Cross-Origin Data Storage Access:<br>This includes restrictions <span class="hljs-keyword">on</span> accessing cookie, localStorage, <span class="hljs-built_in">and</span> IndexedDB.<br></code></pre></td></tr></table></figure><h3 id="How-to-solve-cross-domain-DOM-access"><a href="#How-to-solve-cross-domain-DOM-access" class="headerlink" title="How to solve cross domain DOM access?"></a>How to solve cross domain DOM access?</h3><ol><li>postMessage<br>Window.postMessage () is an HTML5 API that enables communication between the main page and newly opened windows, as well as between created iframes.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// In the parent page file</span><br><span class="hljs-keyword">const</span> childWindow = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://localhost:8080/child-page.html&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>);<br>childWindow.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;hello word&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:8080/child-page.html&#x27;</span>);<br><br><span class="hljs-comment">// In the child page file</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&#x27;message&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">source</span>); <span class="hljs-comment">// the sender&#x27;s window</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">origin</span>); <span class="hljs-comment">// the sender&#x27;s url</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>); <span class="hljs-comment">// the send data</span><br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><ol start="2"><li>document.domain<br>This method is only suitable for situations where the main domain name is the same, such as when xxx.com opens the <a href="http://www.xxx.com/">www.xxx.com</a> page. In this case, you can modify document.domain to xxx.com, so that you can access the other party’s window object and all objects it executes.</li></ol><h3 id="How-to-solve-cross-domain-requests"><a href="#How-to-solve-cross-domain-requests" class="headerlink" title="How to solve cross domain requests?"></a>How to solve cross domain requests?</h3><p>In addition to cross domain DOM, API, and other object access, there is also cross domain request access. If it is still necessary to send requests to addresses from different sources, how can we solve the problem of same source policy?<br>There are actually many methods, and a few can be listed first:</p><h4 id="1-Disable-browser-security-settings"><a href="#1-Disable-browser-security-settings" class="headerlink" title="1. Disable browser security settings"></a>1. Disable browser security settings</h4><p>The same origin strategy is essentially a restriction imposed by the browser, so as long as this restriction is turned off, it can be resolved. However, this only applies to one’s own device and is a temporary solution that does not address the root cause. How to close each browser can be searched by oneself.</p><h4 id="2-set-fet-mode-“no-cors”"><a href="#2-set-fet-mode-“no-cors”" class="headerlink" title="2. set fet mode “no-cors”"></a>2. set fet mode “no-cors”</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:8080/user&#x27;</span>, &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;no-cors&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>&#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">text</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<br></code></pre></td></tr></table></figure><p><img src="/dukeding.github.io/img/Images-Cross-Orign/fetch-mode.png" alt="Alt Text"></p><p>We can see that the status code is <strong>0</strong>, the type is <strong>opaque</strong>, and the received request returns empty, but the console does not report any errors. You can see the correct return within the network of the console.<br>Because of mode:‘ No cors’ does not solve the cross domain problem, but rather tells the browser that you need to send a cross domain request and that you do not care about the return. So, this request will not report any errors, but it will not return any information to the JS, even if the Access Control Allow Origin header has been set. So this setting is only available in certain situations and does not truly solve the problem of cross domain requests.</p><h4 id="3-Do-not-use-AJAX-to-retrieve-data"><a href="#3-Do-not-use-AJAX-to-retrieve-data" class="headerlink" title="3. Do not use AJAX to retrieve data"></a>3. Do not use AJAX to retrieve data</h4><p>If the request is not made using AJAX, there is indeed no such restriction, then the only consideration is HTML tags and form forms.</p><p>When we send a request and create a script tag, this type of request will not be restricted by the same origin policy:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Frontend</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">request</span> = (<span class="hljs-params">url, data, cb</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span> ** <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">const</span> callbackName = <span class="hljs-string">`callback<span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br>  <span class="hljs-keyword">const</span> urlSearchParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>();<br>  <span class="hljs-comment">// send the callback function name to backend</span><br>  urlSearchParams.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;callbackName&#x27;</span>, callbackName);<br>  <span class="hljs-comment">// add params in the url</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    urlSearchParams.<span class="hljs-title function_">set</span>(key, data[key]);<br>  &#125;);<br>  <span class="hljs-comment">// create the script tag</span><br>  <span class="hljs-keyword">const</span> $script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  $script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;urlSearchParams.toString()&#125;</span>`</span>;<br><br>  <span class="hljs-comment">// set a immediate callback and delete it later</span><br>  <span class="hljs-comment">// add the callback function in the window, used to backend send the response to execute the function</span><br>  <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-function">(<span class="hljs-params">...data</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">cb</span>(data);<br>    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">window</span>[callbackName];<br>  &#125;;<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>($script);<br>&#125;;<br><br><span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;localhost:8080/info&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Duke&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;2024&#x27;</span> &#125;, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Retrieve data:&#x27;</span>, data);<br>&#125;);<br></code></pre></td></tr></table></figure><p>Using script tags to bypass cross domain issues and send requests, the server needs to respond to this request and return a JavaScript executable code, triggering our defined temporary callback function and inserting the data:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// backend</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/info&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> id = req.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>;<br>  <span class="hljs-keyword">const</span> name = req.<span class="hljs-property">query</span>.<span class="hljs-property">name</span>;<br>  <span class="hljs-keyword">const</span> callbackName = req.<span class="hljs-property">query</span>.<span class="hljs-property">callbackName</span>;<br>  <span class="hljs-comment">// trigger the callback function</span><br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callbackName&#125;</span>(<span class="hljs-subst">$&#123;id&#125;</span>,&#x27;<span class="hljs-subst">$&#123;name&#125;</span>&#x27;)`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>The front-end passes the data and callback function name to the back-end, and adds the callback function to the window object. The back-end passes the data that needs to be returned to the callback function. After receiving the data, the front-end will directly execute the callback function<br>This is a simple method of sending requests without using AJAX, which is also known as <strong>JSONP</strong> (JSON with Padding). This method was very commonly used when the CORS specification was incomplete in the early days, but its drawbacks were also obvious: only <strong>GET</strong> method can be used. So, how can we send requests for other methods?  </p><p>In fact, we can use the form form. The form itself has no cross domain issues and supports multiple methods. However, it will refresh after submission. So we just need to create an iframe and let the form refresh after submission instead of the main page. Just change the form’s target to the named iframe.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">request</span> = (<span class="hljs-params">url, data, cb</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> $iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>  $iframe.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;request&#x27;</span>;<br>  $iframe.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br><br>  $iframe.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, cb);<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>($iframe);<br><br>  <span class="hljs-keyword">const</span> $form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br><br>  $form.<span class="hljs-property">action</span> = url;<br>  $form.<span class="hljs-property">target</span> = $iframe.<span class="hljs-property">name</span>;   <span class="hljs-comment">// the response displayed in the named iframe</span><br>  $form.<span class="hljs-property">method</span> = <span class="hljs-string">&#x27;get&#x27;</span>;<br>  $form.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;input&#x27;</span>);<br>    node.<span class="hljs-property">name</span> = key;<br>    node.<span class="hljs-property">value</span> = data[key];<br>    $form.<span class="hljs-title function_">appendChild</span>(node);<br>  &#125;);<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>($form);<br>  $form.<span class="hljs-title function_">submit</span>();<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>($form);<br>&#125;;<br></code></pre></td></tr></table></figure><p>The disadvantage of this method is also very obvious: it cannot obtain the returned data.</p><h4 id="4-Proxy-and-forwarding"><a href="#4-Proxy-and-forwarding" class="headerlink" title="4. Proxy and forwarding"></a>4. Proxy and forwarding</h4><p>This method is relatively formal and takes advantage of the server’s lack of such restrictions. As long as the proxy or forwarding service domain name is of the same origin as the front-end domain name, it is sufficient: commonly, the front-end can initiate service forwarding on its own, middleware can return CORS configured headers, or nginx can perform reverse proxy.</p><p>The downside is that there is an additional layer of service, which increases server pressure and slows down the return speed to some extent.</p><h4 id="5-The-server-returns-CORS-response-header"><a href="#5-The-server-returns-CORS-response-header" class="headerlink" title="5. The server returns CORS response header"></a>5. The server returns CORS response header</h4><p>This is the most correct and conventional approach, and it fundamentally solves the cross domain problem once and for all, because this solution completely hands over permissions to the server, which controls whether to allow the frontend to obtain request responses.</p><p>If the downside is, it may be a browser compatibility issue, mainly requiring IE10 or above.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>What happens when you type a URL into your browser?</title>
    <link href="/dukeding.github.io/2023/02/10/What-happens-when-you-type-a-URL-into-your-browser/"/>
    <url>/dukeding.github.io/2023/02/10/What-happens-when-you-type-a-URL-into-your-browser/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Browser-look-up-IP-address-for-the-domain"><a href="#1-Browser-look-up-IP-address-for-the-domain" class="headerlink" title="1. Browser look up IP address for the domain"></a>1. Browser look up IP address for the domain</h2><p>After you have typed the URL on the browser, and press the enter button, the browser needs to figures out which server on the internet to connect to. The browser checks its own cache, system cache, router cache and DNS server cache. If the browser cannot find the ip address at any of those cache layers, the DNS server at you ISP does a recursive DNS lookup.</p><h2 id="2-Browser-initiates-TCP-connection-with-server"><a href="#2-Browser-initiates-TCP-connection-with-server" class="headerlink" title="2. Browser initiates TCP connection with server"></a>2. Browser initiates TCP connection with server</h2><p>The client browser establishes a TCP connection with the server through a three-way handshake.<br><br/></p><ul><li>Step1: Client initiates connection request</li><li>Step2: Server responds to connection request</li><li>Step3: Client acknowledge the connection</li></ul><p>Why is it necessary to initiate a TCP connection before sending an HTTP request?<br><br/><br><em>Because HTTP is an application-layer protocol that relies on the underlying transport-layer protocol, which is usually TCP(transmission control protocol).</em><br><img src="/dukeding.github.io/img/Images-What-happens-when-you-type-a-URL-into-your-browser/http.png" alt="tcp and http connection"></p><h2 id="3-Browser-send-the-HTTP-request-to-the-server"><a href="#3-Browser-send-the-HTTP-request-to-the-server" class="headerlink" title="3. Browser send the HTTP request to the server"></a>3. Browser send the HTTP request to the server</h2><p>After establishing the TCP connection, the browser has a connection to the server. It starts with the browser sending an http request to the server to request the content, this may involve HTML files, CSS, JavaScript, images, videos and so on”.</p><p>What content includes in the http request header?</p><ul><li>The request path</li><li>The request method, which is one of GET, POST, PUT, PATCH, DELETE<br/>What is the difference between HTTP and HTTPS?<br/></li></ul><table><thead><tr><th align="left"></th><th align="left">HTTP</th><th align="left">HTTPS</th></tr></thead><tbody><tr><td align="left">Security</td><td align="left">Plain text transmission</td><td align="left">Encrypted transmission using TLS&#x2F;SSL</td></tr><tr><td align="left">Default Port</td><td align="left">80</td><td align="left">443</td></tr><tr><td align="left">Protocol</td><td align="left">Standard HTTP protocol</td><td align="left">TLS&#x2F;SSL protocol added on top of HTTP</td></tr><tr><td align="left">Certificate</td><td align="left">Not required</td><td align="left">Server need a digital certificate for authentication</td></tr></tbody></table><h2 id="4-Server-processes-the-request-and-sends-back-a-response"><a href="#4-Server-processes-the-request-and-sends-back-a-response" class="headerlink" title="4. Server processes the request and sends back a response"></a>4. Server processes the request and sends back a response</h2><p>For server received the request based on the request line, headers and body decided to how to process the request.</p><p>What content includes in the http <strong>response</strong> header?</p><ul><li><em>The Content-Type, which is one of text&#x2F;plain, text&#x2F;html, text&#x2F;css, text&#x2F;xml, text&#x2F;javascript,  application&#x2F;json</em></li><li><em>Content-length</em></li><li><em>Content-Encoding</em></li><li><em>Cache-Control</em></li><li><em>Expires</em></li><li><em>Last-modified</em></li></ul><h2 id="5-Browser-renders-the-content"><a href="#5-Browser-renders-the-content" class="headerlink" title="5. Browser renders the content"></a>5. Browser renders the content</h2><p>Once the browser received the response from the server, it inspects the response headers for information on how to render the resource. The Content-Type in header tells the browser it received a html file or others.</p><p>What are the steps of rendering?</p><ul><li>Process the HTML file to build DOM tree</li><li>Process the CSS file to build CSSOM tree  </li><li>Merge the DOM tree and CSSOM tree into the Render tree</li><li>Layout(relfow) of the render tree is responsible for calculating the dimensions and position of each element</li><li>Paint each element on the screen</li></ul><h2 id="Reinforcing-Knowledge"><a href="#Reinforcing-Knowledge" class="headerlink" title="Reinforcing Knowledge"></a>Reinforcing Knowledge</h2><p>Browsers use HTTP as an application layer protocol to encapsulate the text information of requests; And using TCP protocol as the transport layer protocol, it is necessary to establish a TCP connection with the server before sending HTTP requests</p><p><img src="/dukeding.github.io/img/Images-What-happens-when-you-type-a-URL-into-your-browser/network-layer.png" alt="network layer"></p>]]></content>
    
    
    
    <tags>
      
      <tag>computer network</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
